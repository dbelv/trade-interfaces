// Partially from: https://github.com/ledgerwatch/interfaces/blob/master/types/types.proto

// @generated by protoc-gen-es v1.2.1 with parameter "target=ts,import_extension=none"
// @generated from file types.proto (package quay, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * @generated from message quay.H40
 */
export class H40 extends Message<H40> {
  /**
   * @generated from field: uint32 hi = 1;
   */
  hi = 0;

  /**
   * Note: lo is really a uint8, however the closest type in Protocol Buffers is uint32. Parsing needs
   *       to take this into consideration.
   *
   * @generated from field: uint32 lo = 2;
   */
  lo = 0;

  constructor(data?: PartialMessage<H40>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quay.H40";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hi", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "lo", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): H40 {
    return new H40().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): H40 {
    return new H40().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): H40 {
    return new H40().fromJsonString(jsonString, options);
  }

  static equals(a: H40 | PlainMessage<H40> | undefined, b: H40 | PlainMessage<H40> | undefined): boolean {
    return proto3.util.equals(H40, a, b);
  }
}

/**
 * @generated from message quay.H96
 */
export class H96 extends Message<H96> {
  /**
   * @generated from field: uint64 hi = 1;
   */
  hi = protoInt64.zero;

  /**
   * @generated from field: uint32 lo = 2;
   */
  lo = 0;

  constructor(data?: PartialMessage<H96>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quay.H96";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hi", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "lo", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): H96 {
    return new H96().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): H96 {
    return new H96().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): H96 {
    return new H96().fromJsonString(jsonString, options);
  }

  static equals(a: H96 | PlainMessage<H96> | undefined, b: H96 | PlainMessage<H96> | undefined): boolean {
    return proto3.util.equals(H96, a, b);
  }
}

/**
 * @generated from message quay.H128
 */
export class H128 extends Message<H128> {
  /**
   * @generated from field: uint64 hi = 1;
   */
  hi = protoInt64.zero;

  /**
   * @generated from field: uint64 lo = 2;
   */
  lo = protoInt64.zero;

  constructor(data?: PartialMessage<H128>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quay.H128";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hi", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "lo", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): H128 {
    return new H128().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): H128 {
    return new H128().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): H128 {
    return new H128().fromJsonString(jsonString, options);
  }

  static equals(a: H128 | PlainMessage<H128> | undefined, b: H128 | PlainMessage<H128> | undefined): boolean {
    return proto3.util.equals(H128, a, b);
  }
}

/**
 * @generated from message quay.H160
 */
export class H160 extends Message<H160> {
  /**
   * @generated from field: quay.H128 hi = 1;
   */
  hi?: H128;

  /**
   * @generated from field: uint32 lo = 2;
   */
  lo = 0;

  constructor(data?: PartialMessage<H160>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quay.H160";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hi", kind: "message", T: H128 },
    { no: 2, name: "lo", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): H160 {
    return new H160().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): H160 {
    return new H160().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): H160 {
    return new H160().fromJsonString(jsonString, options);
  }

  static equals(a: H160 | PlainMessage<H160> | undefined, b: H160 | PlainMessage<H160> | undefined): boolean {
    return proto3.util.equals(H160, a, b);
  }
}

/**
 * @generated from message quay.H256
 */
export class H256 extends Message<H256> {
  /**
   * @generated from field: quay.H128 hi = 1;
   */
  hi?: H128;

  /**
   * @generated from field: quay.H128 lo = 2;
   */
  lo?: H128;

  constructor(data?: PartialMessage<H256>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quay.H256";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hi", kind: "message", T: H128 },
    { no: 2, name: "lo", kind: "message", T: H128 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): H256 {
    return new H256().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): H256 {
    return new H256().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): H256 {
    return new H256().fromJsonString(jsonString, options);
  }

  static equals(a: H256 | PlainMessage<H256> | undefined, b: H256 | PlainMessage<H256> | undefined): boolean {
    return proto3.util.equals(H256, a, b);
  }
}

/**
 * ECDSA signatures in Ethereum consist of three parameters: v, r and s. The signature is always 65-bytes in length.
 *    r = first 32 bytes of signature
 *    s = second 32 bytes of signature
 *    v = final 1 byte of signature
 * Since protobuf doesn't support uint8, we use a boolean for v, which is always 8 bits.
 *
 * @generated from message quay.EthSignature
 */
export class EthSignature extends Message<EthSignature> {
  /**
   * @generated from field: bytes r = 1;
   */
  r = new Uint8Array(0);

  /**
   * @generated from field: bytes s = 2;
   */
  s = new Uint8Array(0);

  /**
   * @generated from field: bytes v = 3;
   */
  v = new Uint8Array(0);

  constructor(data?: PartialMessage<EthSignature>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quay.EthSignature";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "r", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "s", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "v", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EthSignature {
    return new EthSignature().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EthSignature {
    return new EthSignature().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EthSignature {
    return new EthSignature().fromJsonString(jsonString, options);
  }

  static equals(a: EthSignature | PlainMessage<EthSignature> | undefined, b: EthSignature | PlainMessage<EthSignature> | undefined): boolean {
    return proto3.util.equals(EthSignature, a, b);
  }
}

