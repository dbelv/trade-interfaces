// @generated by protoc-gen-es v1.2.1 with parameter "target=ts,import_extension=none"
// @generated from file seaport.proto (package quay, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { EthSignature, H160, H256 } from "./types_pb";

/**
 * * The ItemType designates the type of item, with valid types being Ether
 * (or other native token for the given chain), ERC20, ERC721, ERC1155,
 * ERC721 with "criteria" (explained below), and ERC1155 with criteria.
 *
 * @generated from enum quay.ItemType
 */
export enum ItemType {
  /**
   * @generated from enum value: NATIVE = 0;
   */
  NATIVE = 0,

  /**
   * @generated from enum value: ERC20 = 1;
   */
  ERC20 = 1,

  /**
   * @generated from enum value: ERC721 = 2;
   */
  ERC721 = 2,

  /**
   * @generated from enum value: ERC1155 = 3;
   */
  ERC1155 = 3,

  /**
   * @generated from enum value: ERC721_WITH_CRITERIA = 4;
   */
  ERC721_WITH_CRITERIA = 4,

  /**
   * @generated from enum value: ERC1155_WITH_CRITERIA = 5;
   */
  ERC1155_WITH_CRITERIA = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(ItemType)
proto3.util.setEnumType(ItemType, "quay.ItemType", [
  { no: 0, name: "NATIVE" },
  { no: 1, name: "ERC20" },
  { no: 2, name: "ERC721" },
  { no: 3, name: "ERC1155" },
  { no: 4, name: "ERC721_WITH_CRITERIA" },
  { no: 5, name: "ERC1155_WITH_CRITERIA" },
]);

/**
 * * The OrderType designates one of four types for the order depending on
 * two distinct preferences:
 *
 * FULL indicates that the order does not support partial fills,
 * whereas PARTIAL enables filling some fraction of the order, with the
 * important caveat that each item must be cleanly divisible by the supplied
 * fraction (i.e. no remainder after division).
 *
 * OPEN indicates that the call to execute the order can be submitted by
 * any account, whereas RESTRICTED requires that the order either be executed
 * by the offerer or the zone of the order, or that a magic value indicating
 * that the order is approved is returned upon calling validateOrder on
 * the zone.
 *
 * @generated from enum quay.OrderType
 */
export enum OrderType {
  /**
   * @generated from enum value: FULL_OPEN = 0;
   */
  FULL_OPEN = 0,

  /**
   * @generated from enum value: PARTIAL_OPEN = 1;
   */
  PARTIAL_OPEN = 1,

  /**
   * @generated from enum value: FULL_RESTRICTED = 2;
   */
  FULL_RESTRICTED = 2,

  /**
   * @generated from enum value: PARTIAL_RESTRICTED = 3;
   */
  PARTIAL_RESTRICTED = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(OrderType)
proto3.util.setEnumType(OrderType, "quay.OrderType", [
  { no: 0, name: "FULL_OPEN" },
  { no: 1, name: "PARTIAL_OPEN" },
  { no: 2, name: "FULL_RESTRICTED" },
  { no: 3, name: "PARTIAL_RESTRICTED" },
]);

/**
 * *
 * This is and item required in exchange for an offer.
 *
 * @generated from message quay.ConsiderationItem
 */
export class ConsiderationItem extends Message<ConsiderationItem> {
  /**
   * @generated from field: quay.ItemType item_type = 1;
   */
  itemType = ItemType.NATIVE;

  /**
   * @generated from field: quay.H160 token = 2;
   */
  token?: H160;

  /**
   * uint256
   *
   * @generated from field: quay.H256 identifier_or_criteria = 3;
   */
  identifierOrCriteria?: H256;

  /**
   * uint256
   *
   * @generated from field: quay.H256 start_amount = 4;
   */
  startAmount?: H256;

  /**
   * uint256
   *
   * @generated from field: quay.H256 end_amount = 5;
   */
  endAmount?: H256;

  /**
   * @generated from field: quay.H160 recipient = 6;
   */
  recipient?: H160;

  constructor(data?: PartialMessage<ConsiderationItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quay.ConsiderationItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "item_type", kind: "enum", T: proto3.getEnumType(ItemType) },
    { no: 2, name: "token", kind: "message", T: H160 },
    { no: 3, name: "identifier_or_criteria", kind: "message", T: H256 },
    { no: 4, name: "start_amount", kind: "message", T: H256 },
    { no: 5, name: "end_amount", kind: "message", T: H256 },
    { no: 6, name: "recipient", kind: "message", T: H160 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConsiderationItem {
    return new ConsiderationItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConsiderationItem {
    return new ConsiderationItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConsiderationItem {
    return new ConsiderationItem().fromJsonString(jsonString, options);
  }

  static equals(a: ConsiderationItem | PlainMessage<ConsiderationItem> | undefined, b: ConsiderationItem | PlainMessage<ConsiderationItem> | undefined): boolean {
    return proto3.util.equals(ConsiderationItem, a, b);
  }
}

/**
 * *
 * This is an item offered in exchange for consideration.
 *
 * @generated from message quay.OfferItem
 */
export class OfferItem extends Message<OfferItem> {
  /**
   * @generated from field: quay.ItemType item_type = 1;
   */
  itemType = ItemType.NATIVE;

  /**
   * * The token designates the account of the item's token contract
   * (with the null address used for Ether or other native tokens).
   *
   * @generated from field: quay.H160 token = 2;
   */
  token?: H160;

  /**
   * * The identifier_or_criteria represents either the ERC721 or ERC1155
   * token identifier or, in the case of a criteria-based item type, a
   * merkle root composed of the valid set of token identifiers for
   * the item. This value will be ignored for Ether and ERC20 item types,
   * and can optionally be zero for criteria-based item types to allow
   * for any identifier.
   *
   * @generated from field: quay.H256 identifier_or_criteria = 3;
   */
  identifierOrCriteria?: H256;

  /**
   * * The start_amount represents the amount of the item in question that
   * will be required should the order be fulfilled at the moment the
   * order becomes active.
   *
   * @generated from field: quay.H256 start_amount = 4;
   */
  startAmount?: H256;

  /**
   * * The end_amount represents the amount of the item in question that
   * will be required should the order be fulfilled at the moment the
   * order expires. If this value differs from the item's start_amount,
   * the realized amount is calculated linearly based on the time elapsed
   * since the order became active.
   *
   * uint256
   *
   * @generated from field: quay.H256 end_amount = 5;
   */
  endAmount?: H256;

  constructor(data?: PartialMessage<OfferItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quay.OfferItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "item_type", kind: "enum", T: proto3.getEnumType(ItemType) },
    { no: 2, name: "token", kind: "message", T: H160 },
    { no: 3, name: "identifier_or_criteria", kind: "message", T: H256 },
    { no: 4, name: "start_amount", kind: "message", T: H256 },
    { no: 5, name: "end_amount", kind: "message", T: H256 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OfferItem {
    return new OfferItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OfferItem {
    return new OfferItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OfferItem {
    return new OfferItem().fromJsonString(jsonString, options);
  }

  static equals(a: OfferItem | PlainMessage<OfferItem> | undefined, b: OfferItem | PlainMessage<OfferItem> | undefined): boolean {
    return proto3.util.equals(OfferItem, a, b);
  }
}

/**
 * * Each order contains ten key components 
 *
 * @generated from message quay.Order
 */
export class Order extends Message<Order> {
  /**
   * * The offerer of the order supplies all offered items and must either
   * fulfill the order personally (i.e. msg.sender == offerer) or approve
   * the order via signature (either standard 65-byte EDCSA, 64-byte
   * EIP-2098, or an EIP-1271 isValidSignature check) or by listing
   * the order on-chain (i.e. calling validate).
   *
   * @generated from field: quay.H160 offerer = 1;
   */
  offerer?: H160;

  /**
   * * The zone of the order is an optional secondary account attached to the
   * order with two additional privileges:
   *
   * The zone may cancel orders where it is named as the zone by calling
   * cancel. (Note that offerers can also cancel their own orders, either
   * individually or for all orders signed with their current counter at
   * once by calling incrementCounter).
   * "Restricted" orders (as specified by the order type) must either be
   * executed by the zone or the offerer, or must be approved as indicated
   * by a call to an validateOrder on the zone.
   *
   * @generated from field: quay.H160 zone = 2;
   */
  zone?: H160;

  /**
   * * The offers array contains an array of items that may be transferred
   * from the offerer's account.
   *
   * @generated from field: repeated quay.OfferItem offers = 3;
   */
  offers: OfferItem[] = [];

  /**
   * * The consideration contains an array of items that must be received
   * in order to fulfill the order. It contains all of the same components
   * as an offered item, and additionally includes a recipient that will
   * receive each item. This array may be extended by the fulfiller on
   * order fulfillment so as to support "tipping" (e.g. relayer or
   * referral payments)
   *
   * @generated from field: repeated quay.ConsiderationItem considerations = 4;
   */
  considerations: ConsiderationItem[] = [];

  /**
   * @generated from field: quay.OrderType order_type = 5;
   */
  orderType = OrderType.FULL_OPEN;

  /**
   * * The start_time indicates the block timestamp at which the order
   * becomes active.
   *
   * @generated from field: quay.H256 start_time = 6;
   */
  startTime?: H256;

  /**
   * * The end_time indicates the block timestamp at which the order expires.
   * This value and the startTime are used in conjunction with the
   * start_amount and end_amount of each item to derive their current amount.
   *
   * @generated from field: quay.H256 end_time = 7;
   */
  endTime?: H256;

  /**
   * * The zoneHash represents an arbitrary 32-byte value that will be
   * supplied to the zone when fulfilling restricted orders that the zone
   * can utilize when making a determination on whether to authorize the order.
   *
   * @generated from field: quay.H256 zone_hash = 8;
   */
  zoneHash?: H256;

  /**
   * * The salt represents an arbitrary source of entropy for the order. 
   *
   * @generated from field: quay.H256 salt = 9;
   */
  salt?: H256;

  /**
   * * The conduit_key is a bytes32 value that indicates what conduit,
   * if any, should be utilized as a source for token approvals when
   * performing transfers. By default (i.e. when conduitKey is set to the
   * zero hash), the offerer will grant ERC20, ERC721, and ERC1155 token
   * approvals to Seaport directly so that it can perform any transfers
   * specified by the order during fulfillment. In contrast, an offerer
   * that elects to utilize a conduit will grant token approvals to the
   * conduit contract corresponding to the supplied conduit key, and
   * Seaport will then instruct that conduit to transfer the respective
   * tokens.
   *
   * @generated from field: quay.H256 conduit_key = 10;
   */
  conduitKey?: H256;

  constructor(data?: PartialMessage<Order>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quay.Order";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "offerer", kind: "message", T: H160 },
    { no: 2, name: "zone", kind: "message", T: H160 },
    { no: 3, name: "offers", kind: "message", T: OfferItem, repeated: true },
    { no: 4, name: "considerations", kind: "message", T: ConsiderationItem, repeated: true },
    { no: 5, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 6, name: "start_time", kind: "message", T: H256 },
    { no: 7, name: "end_time", kind: "message", T: H256 },
    { no: 8, name: "zone_hash", kind: "message", T: H256 },
    { no: 9, name: "salt", kind: "message", T: H256 },
    { no: 10, name: "conduit_key", kind: "message", T: H256 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Order {
    return new Order().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Order {
    return new Order().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Order {
    return new Order().fromJsonString(jsonString, options);
  }

  static equals(a: Order | PlainMessage<Order> | undefined, b: Order | PlainMessage<Order> | undefined): boolean {
    return proto3.util.equals(Order, a, b);
  }
}

/**
 * @generated from message quay.SignedOrder
 */
export class SignedOrder extends Message<SignedOrder> {
  /**
   * @generated from field: quay.Order parameters = 1;
   */
  parameters?: Order;

  /**
   * @generated from field: quay.EthSignature signature = 2;
   */
  signature?: EthSignature;

  constructor(data?: PartialMessage<SignedOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quay.SignedOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parameters", kind: "message", T: Order },
    { no: 2, name: "signature", kind: "message", T: EthSignature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SignedOrder {
    return new SignedOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SignedOrder {
    return new SignedOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SignedOrder {
    return new SignedOrder().fromJsonString(jsonString, options);
  }

  static equals(a: SignedOrder | PlainMessage<SignedOrder> | undefined, b: SignedOrder | PlainMessage<SignedOrder> | undefined): boolean {
    return proto3.util.equals(SignedOrder, a, b);
  }
}

